<HTML>
<HEAD>
<META name=vsisbn content="0471503363">
<META name=vstitle content="Art of Computer Systems Performance Analysis Techniques For Experimental Design Measurements Simulation And Modeling">
<META name=vsauthor content="Raj Jain">
<META name=vsimprint content="Wiley Computer Publishing">
<META name=vspublisher content="John Wiley & Sons, Inc.">
<META name=vspubdate content="05/01/91">
<META name=vscategory content="Web and Software Development: Software Engineering: Simulation and Modeling">







<TITLE>The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling:Program Execution Monitors and Accounting Logs</TITLE>

<!-- HEADER -->

<STYLE type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
</STYLE>

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<!--ISBN=0471503363//-->
<!--TITLE=The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling//-->
<!--AUTHOR=Raj Jain//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=08//-->
<!--PAGES=111-114//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="../ch07/07-06.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="08-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">CHAPTER 8<BR>PROGRAM EXECUTION MONITORS AND ACCOUNTING LOGS
</FONT></H2>
<BLOCKQUOTE>
<P ALIGN="RIGHT"><I>Measurements are not to provide numbers but insight</I>.</P>
<P ALIGN="RIGHT">&#151;Ingrid Bucher</P>
</BLOCKQUOTE><P>There are two monitors that deserve special discussion since they are used so frequently. Program execution monitors, also known as program optimizers or program execution analyzers, are software monitors designed to observe application software. They help improve the performance of the programs.
</P>
<P>Most computer systems keep an accounting log where the resources used by the users and their processes are recorded. Although the primary aim of such logs is for accounting and billing, they are also a good source of information about resource usage.</P>
<P>The issues related to design and use of these two monitors are the topics of this chapter.</P>
<H3><A NAME="Heading2"></A><FONT COLOR="#000077">8.1 PROGRAM EXECUTION MONITORS</FONT></H3>
<P>There are many reasons for monitoring the execution of a program. Some of these are the following:
</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;<I>Tracing</I>: To find the execution path of a program.
<DD><B>&#149;</B>&nbsp;&nbsp;<I>Timing</I>: To find the time spent in various modules of the program.
<DD><B>&#149;</B>&nbsp;&nbsp;<I>Tuning</I>: To find the most frequent or most time-consuming sections of the code.
<P><A NAME="Fig1"></A><A HREF="javascript:displayWindow('images/08-01.jpg',500,188 )"><IMG SRC="images/08-01t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/08-01.jpg',500,188)"><FONT COLOR="#000077"><B>FIGURE 8.1</B></FONT></A>&nbsp;&nbsp;Steps in program execution monitoring.</P>
<DD><B>&#149;</B>&nbsp;&nbsp;<I>Assertion Checking</I>: To verify the relationships assumed among the variables of a program.
<DD><B>&#149;</B>&nbsp;&nbsp;<I>Coverage Analysis</I>: To determine the adequacy of a test run.
</DL>
<P>Notice that not all applications of program execution monitors are related to the program&#146;s performance, although that may be the most common use of these monitors.
</P>
<P>The programs to be monitored and improved should be chosen based on a number of criteria. The first criterion is the time criticality. Some programs are very time critical, and it is important to find out where the time is being spent so that the response can be improved. The second criterion is frequency of use. Programs used with high frequency should be optimized first. Finally, programs consuming the highest percentage of resources should be optimized. The resources include CPU time, I/O time, or elapsed (people) time. The most expensive resource should be optimized first. With the decreasing cost of computing resources, the people time is becoming the most expensive resource and may need to be optimized first.</P>
<P>Figure 8.1 shows the typical steps involved in program execution monitoring. First, instrumentation (or hooks) are added to the target program. The instrumented program is then run under the control of the execution monitor. Finally, the reports generated by the monitor are examined. Often the procedure is repeated several times and new instrumentation is added as more information about the execution profile of the program is obtained.</P>
<H4 ALIGN="LEFT"><A NAME="Heading3"></A><FONT COLOR="#000077">8.1.1 Issues in Designing a Program Execution Monitor</FONT></H4>
<P>In designing an execution monitor, most of the issues to be considered are similar to those discussed in Section 7.3.1 on software monitor design. In addition, there are a number of issues that are specific to program execution monitors. These issues are as follows:
</P>
<DL>
<DD><B>1.</B>&nbsp;&nbsp;<I>Measurement Unit</I>: The execution monitor divides the program into smaller measurement units such as modules, subroutines, high-level language statements, or machine instructions. The data related to the execution of each unit is recorded and shown in the final report. The lower the level of the unit, the more the overhead of monitoring. Lower level reports (such as machine instruction execution profiles) may be too detailed for some applications. Some monitors use higher level language statements, such as COBOL or PL/I statements, as a measurement unit, but then they also become language dependent. As a result, a program written in a mix of languages may not be correctly observed by such monitors.
<DD><B>2.</B>&nbsp;&nbsp;<I>Measurement Technique</I>: The two basic measurement techniques are tracing and sampling. Tracing can be performed by using either explicit hooks such as trap instructions or by the trace mode of the processor. Using the trace mode produces too much unwanted data and is suitable only for monitors operating at machine instruction level. The sampling monitors make use of the system timer facilities and record the program states at periodic intervals. The interval may be specified in terms of CPU time or in terms of elapsed time. If CPU time sampling is used, the program is always found in the execution state. On the other hand, if elasped time sampling is used, the program may be in a wait state, waiting for I/O completion or for some other event.
<DD><B>3.</B>&nbsp;&nbsp;<I>Instrumentation Mechanism</I>: A program has to be compiled and linked before it can be executed. The instrumentation can be added before compilation, during compilation, after compilation (before linking), or during run time. In other words, a program can be instrumented by augmenting the source code, the compiler-generated object code, the run time environment, the operating system, or the hardware. Often, a combination of these techniques is used. Source code instrumentation requires the addition of high-level procedure call statements at strategic locations in the program. The call statements transfer control to the monitor routines, which collect the data. Run time instrumentation is accomplished by adding a sampling monitor to the run time environment of the program.
<BR>Execution monitors may also make use of additional information. For example, the link-edit map produced by the linker is an excellent source of symbol-to-address map that is used by most execution monitors.
<DD><B>4.</B>&nbsp;&nbsp;<I>Profile Report</I>: Most program monitors produce an execution profile showing a frequency and time histogram. For large programs, several summaries at different levels of hierarchy may be presented; for example, summaries by modules, and then for each module by procedures, and for each procedure by statements. The procedure profiles may distinguish between resources used directly by a procedure and those used by a subprocedure that was invoked by it. For CPU time, these resources are called <B>self-time</B> and <B>inherited time</B>, respectively. Many monitors have the ability to limit or expand (zoom in or zoom out) the amount of detail.
</DL>
<P>Having designed a program execution monitor and used it to monitor a set of critical programs, the next issue that an analyst may face is to suggest ways to improve the performance of the programs. This issue is discussed next.
</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="../ch07/07-06.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="08-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Copyright &copy; <a href="/reference/wiley00001.html">John Wiley &amp; Sons, Inc.</a></font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

</BODY>
</HTML>

<!-- END FOOTER -->

