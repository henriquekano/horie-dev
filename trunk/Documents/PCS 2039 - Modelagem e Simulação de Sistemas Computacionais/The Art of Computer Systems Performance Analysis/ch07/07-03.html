<HTML>
<HEAD>
<META name=vsisbn content="0471503363">
<META name=vstitle content="Art of Computer Systems Performance Analysis Techniques For Experimental Design Measurements Simulation And Modeling">
<META name=vsauthor content="Raj Jain">
<META name=vsimprint content="Wiley Computer Publishing">
<META name=vspublisher content="John Wiley & Sons, Inc.">
<META name=vspubdate content="05/01/91">
<META name=vscategory content="Web and Software Development: Software Engineering: Simulation and Modeling">







<TITLE>The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling:Monitors</TITLE>

<!-- HEADER -->

<STYLE type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
</STYLE>

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<!--ISBN=0471503363//-->
<!--TITLE=The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling//-->
<!--AUTHOR=Raj Jain//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=07//-->
<!--PAGES=098-101//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="07-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="07-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H3><A NAME="Heading7"></A><FONT COLOR="#000077">7.5 SOFTWARE VERSUS HARDWARE MONITORS</FONT></H3>
<P>Given a monitoring problem, should a hardware monitor or a software monitor be used? The choice is not as difficult as it may appear. For most applications, only one of the two types of monitors will be satisfactory.
</P>
<P>The first step in selecting the monitor is to consider what needs to be measured. Hardware monitors can sense electrical signals on the busses and can accurately record them even at high speed. However, it is difficult for them to determine higher level information, such as queue lengths or current user, unless the information is easily available in a hardware register. Software monitors, conversely, can easily determine the higher level information but cannot easily observe low-level events, such as time to fetch an operation code for an instruction. Examples of variables that can be observed by both types of monitors are device utilizations and CPU-I/O overlap.</P>
<P>The second consideration is the input rate, the rate at which events have to be observed. Hardware monitors can record events very quickly. A software monitor, on the other hand, may require a few hundred instructions per observation and so cannot be used if the interevent time is small.</P>
<P>The time resolution required is the next consideration. A hardware monitor has a separate hardware clock and can provide time resolution in a few nanoseconds. The software monitors use the system clock, which typically has a resolution of a few milliseconds.</P>
<P>The expertise of the performance analyst also should be taken into consideration in selecting the monitor. Only an analyst with a good knowledge of the system hardware can correctly use a hardware monitor. A software monitor, on the other hand, requires an intimate knowledge of the system software to be instrumented.</P>
<P>The amount of data recorded directly affects the overhead of a software monitor. If the amount is expected to be huge, a hardware monitor with builtin secondary storage may be used.</P>
<P>A software monitor, by its nature, is sequential in that it cannot record several simultaneous events (unless the software is distributed). For example, if several devices request service from the processor and post an interrupt, the interrupts will be serviced sequentially and will be observed by the software monitor sequentially. Hardware monitors have several probes that can record simultaneous events.</P>
<P>Software monitors consume system resources that would otherwise be available to the users. A hardware monitor, on the other hand, consumes little, if any, of the system resources. Its presence may or may not be visible to the system.</P>
<P>Most hardware monitors are designed to be attached to a variety of systems. Thus, the same monitor can be used to monitor systems from different vendors or systems using different operating systems. Software monitors are developed specifically for a particular hardware and software base and cannot be easily parted across vendors.</P>
<P>A hardware monitor keeps observing the system even when it is malfunctioning, and thus, it can be used to debug the system. A software monitor may not be able to observe correctly during malfunctions, and it may not run at all when the system is down.</P>
<TABLE WIDTH="100%"><TH CAPTION VALIGN="TOP" ALIGN="LEFT" COLSPAN="3">TABLE 7.1 Comparison of Hardware and Software Monitors
<TR>
<TD COLSPAN="3"><HR>
<TR>
<TH VALIGN="TOP" WIDTH="25%" ALIGN="LEFT">Criterion
<TH VALIGN="TOP" WIDTH="35%" ALIGN="LEFT">Hardware Monitor
<TH VALIGN="TOP" WIDTH="40%" ALIGN="LEFT">Software Monitor
<TR>
<TD COLSPAN="3"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Domain
<TD VALIGN="TOP" ALIGN="LEFT">Difficult to monitor operating system events.
<TD VALIGN="TOP" ALIGN="LEFT">Difficult to monitor hardware events unless recognizable by an instruction.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Input rate
<TD VALIGN="TOP" ALIGN="LEFT">Sampling rates of 10<SUP><SMALL>5</SMALL></SUP> per second possible.
<TD VALIGN="TOP" ALIGN="LEFT">Sampling rate limited by the processor MIPS and overhead required.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Time resolution
<TD VALIGN="TOP" ALIGN="LEFT">10 nanoseconds is possible.
<TD VALIGN="TOP" ALIGN="LEFT">Generally 10 to 16 milliseconds.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Expertise
<TD VALIGN="TOP" ALIGN="LEFT">Requires intimate knowledge of hardware.
<TD VALIGN="TOP" ALIGN="LEFT">Requires intimate knowledge of software.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Recording capacity
<TD VALIGN="TOP" ALIGN="LEFT">Limited by memory and secondary storage. Not a problem currently.
<TD VALIGN="TOP" ALIGN="LEFT">Limited by overhead desired.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Input width
<TD VALIGN="TOP" ALIGN="LEFT">Can record several simultaneous events.
<TD VALIGN="TOP" ALIGN="LEFT">Cannot record several simultaneous events unless there are multiple processors.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Monitor overhead
<TD VALIGN="TOP" ALIGN="LEFT">None
<TD VALIGN="TOP" ALIGN="LEFT">Overhead depends upon the input rate and input width. Less than 5% adequate and more than 100% possible.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Portability
<TD VALIGN="TOP" ALIGN="LEFT">Generally portable.
<TD VALIGN="TOP" ALIGN="LEFT">Specific to an operating system.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Availability
<TD VALIGN="TOP" ALIGN="LEFT">Monitoring continues even during system malfunction or failure.
<TD VALIGN="TOP" ALIGN="LEFT">Cannot monitor during system crash.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Errors
<TD VALIGN="TOP" ALIGN="LEFT">Possible to connect the probes to wrong points.
<TD VALIGN="TOP" ALIGN="LEFT">Once debugged, errors are rare.
<TR>
<TD VALIGN="TOP" ALIGN="LEFT">Cost
<TD VALIGN="TOP" ALIGN="LEFT">High
<TD VALIGN="TOP" ALIGN="LEFT">Medium
<TR>
<TD COLSPAN="3"><HR>
</TABLE>
<P>Both hardware and software monitors can have bugs that can introduce errors into the measured data. However, with software monitors, once the software has been thoroughly debugged, errors are rare. With a fully debugged hardware monitor, it is possible to misplace probes.
</P>
<P>Finally, and most importantly, hardware monitors are more expensive than software monitors. This fact alone may be sufficient to bias the choice in many cases.</P>
<P>The issues of hardware versus software monitors are summarized in Table 7.1.</P>
<H3><A NAME="Heading8"></A><FONT COLOR="#000077">7.6 FIRMWARE AND HYBRID MONITORS</FONT></H3>
<P>Firmware monitors are implemented by modifying the processor microcode. These are useful for applications that fall between the software and hardware monitoring boundaries. In most respects, firmware monitors are similar to software monitors. However, since the microcode space is limited and there are tighter timing limitations, firmware monitors generally do very limited data reduction, if any. They are useful in applications where the timing considerations preclude the use of software monitors and inaccessability of probe points preclude the use of hardware monitors.
</P>
<P>Firmware monitors have been used for network monitoring where existing network interfaces can be easily microprogrammed to monitor all traffic on the network. Another application suitable for firmware monitors is generating address profiles of microcode (micro-PC histograms). These profiles are used for optimizing the code.</P>
<P>A monitor using a combination of software, hardware, or firmware is a hybrid monitor. Software monitors have good data reduction capabilities, while hardware monitors have high resolution. Thus, a hybrid monitor, consisting of a hardware data-gathering component together with a software data reduction component, provides the best of both worlds.</P>
<P>An example of a hybrid monitor is the Diamond monitor described by Hughes (1980). The hardware part of the monitor consists of a board placed in the system cabinet. It can observe all traffic on the system bus. The software part can read instruction addresses, processor modes, and system and user identifications. The two parts can communicate through device status and control registers. The monitor has been used to generate address histograms, address traces, instruction traces, and others.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="07-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="07-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Copyright &copy; <a href="/reference/wiley00001.html">John Wiley &amp; Sons, Inc.</a></font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

</BODY>
</HTML>

<!-- END FOOTER -->

