<HTML>
<HEAD>
<META name=vsisbn content="0471503363">
<META name=vstitle content="Art of Computer Systems Performance Analysis Techniques For Experimental Design Measurements Simulation And Modeling">
<META name=vsauthor content="Raj Jain">
<META name=vsimprint content="Wiley Computer Publishing">
<META name=vspublisher content="John Wiley & Sons, Inc.">
<META name=vspubdate content="05/01/91">
<META name=vscategory content="Web and Software Development: Software Engineering: Simulation and Modeling">







<TITLE>The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling:Mean-Value Analysis and Related Techniques</TITLE>

<!-- HEADER -->

<STYLE type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
</STYLE>

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<!--ISBN=0471503363//-->
<!--TITLE=The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling//-->
<!--AUTHOR=Raj Jain//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=34//-->
<!--PAGES=579-582//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="34-04.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="34-06.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H3><A NAME="Heading4"></A><FONT COLOR="#000077">34.3 APPROXIMATE MVA</FONT></H3>
<P>Mean-value analysis is a recursive algorithm. Computation of performance with <I>N</I> jobs in the network requires knowledge of performance with <I>N</I> &#150; 1 jobs. Since performance with <I>N</I> = 0 is trivially known, we always start the analysis with <I>N</I> = 0 and compute the performance for <I>N</I> = 1,2,... successively. For small values of <I>N</I>, this procedure is not computationally too expensive. However, for large values of <I>N</I>, particularly if the performance for smaller values of N is not required, it would be preferable to avoid this recursion. Several approximate analysis techniques have been developed with this goal. Here we describe one such approximation technique known as <B>Schweitzer&#146;s approximation</B>. It avoids the recursion in MVA by appropriately estimating the queue lengths with <I>N</I> jobs and computing the response times and throughputs. The values so computed can be used to recompute the queue lengths, and if the previous estimate was good, the new computed value would be close to the estimate.</P>
<P>The approximation, due to Schweitzer (1979), is based on the assumption that as the number of jobs in a network increases, the queue length at each device increases proportionately. For example, doubling the number of jobs in the network will result in doubling the number of jobs at each device. Analytically:</P>
<P><P ALIGN="CENTER"><IMG SRC="images/34-05d.jpg"></P>
</P>
<P>In particular, this implies</P>
<P><P ALIGN="CENTER"><IMG SRC="images/34-06d.jpg"></P>
</P>
<P>or</P>
<P><P ALIGN="CENTER"><IMG SRC="images/34-07d.jpg"></P>
</P>
<P>The MVA equations can therefore be written as follows:</P>
<P><P ALIGN="CENTER"><IMG SRC="images/34-08d.jpg"></P>
</P>
<P>Notice that the each iteration starts with some values for number of jobs <I>Q</I><SUB><I><SMALL>i</SMALL></I></SUB>(<I>N</I>) at various devices and ends by recomputing new values for <I>Q</I><SUB><I><SMALL>i</SMALL></I></SUB>(<I>N</I>). If the new values are not close to the values at the start of the iteration, we need to continue iterating. If they are sufficiently close, we stop. There is no guarantee that the successive iterations will converge. However, Bard (1979) tried several cases and found that it converges in almost all cases.</P>
<P>The initial values for queue lengths should not affect the final result, although they may affect the number of iterations required. One alternative is to start with all queue lengths being equal.</P>

<TABLE BORDER="2" BORDERCOLOR="#0000" ALIGN="CENTER">
<TR><TD>
<DL>
<DD><B>Box 34.3 MVA Algorithm Using Schweitzer&#146;s Approximation</B>
</DL>
<DL>
<DD>Inputs:
<DD><I>N</I> = number of users
<DD><I>Z</I> = think time
<DD><I>M</I> = number of devices (not including terminals)
<DD><I>S</I><SUB><I><SMALL>i</SMALL></I></SUB> = service time per visit to the <I>i</I>th device
<DD><I>V</I><SUB><I><SMALL>i</SMALL></I></SUB> = number of visits to the <I>i</I>th device
<DD>&#949; = maximum allowable error in queue length
</DL>
<DL>
<DD>Outputs:
<DD><I>X</I> = system throughput
<DD><I>Q</I><SUB><I><SMALL>i</SMALL></I></SUB> = average number of jobs at the <I>i</I>th device
<DD><I>R</I><SUB><I><SMALL>i</SMALL></I></SUB> = response time of the <I>i</I>th device
<DD><I>R</I> = system response time
<DD><I>U</I><SUB><I><SMALL>i</SMALL></I></SUB> = utilization of the <I>i</I>th device
</DL>
<DL>
<DD>Initialization:
<DD><I>X</I> = 0
<DD>FOR <I>i</I> = 1 TO <I>M</I> DO <I>Q</I><SUB><I><SMALL>i</SMALL></I></SUB> = <I>N/M</I>
</DL>
<DL>
<DD>Iteration:
<DD>WHILE max<SUB><I>i</I></SUB>{|<I>Q<SUB>i</SUB></I> - <I>XR<SUB>i</SUB>V<SUB>i</SUB></I>|}&gt; &#949; DO
<DD>BEGIN
<BR><P ALIGN="CENTER"><IMG SRC="images/34-09d.jpg"></P>
<DD>END
</DL>
<DL>
<DD>Device throughputs: <I>X</I><SUB><I><SMALL>i</SMALL></I></SUB> = <I>XV</I><SUB><I><SMALL>i</SMALL></I></SUB>
<DD>Device utilizations: <I>U</I><SUB><I><SMALL>i</SMALL></I></SUB> = <I>XS</I><SUB><I><SMALL>i</SMALL></I></SUB><I>V</I><SUB><I><SMALL>i</SMALL></I></SUB>
</DL>
</TABLE>

<P>The complete MVA algorithm using Schweitzer&#146;s approximation is summarized in Box 34.3.
</P>
<DL>
<DD><B>Example 34.3</B> Consider again the timesharing system of Example 34.2. Let us analyze this model using Schweitzer&#146;s approximation when there are 20 users on the system. The stopping criterion is to stop when the maximum absolute change in every queue length is less than 0.01. The system parameters are
</DL>
<P ALIGN="CENTER"><I>S</I><SUB><I><SMALL>A</SMALL></I></SUB> = 0.3, <I>V</I><SUB><I><SMALL>A</SMALL></I></SUB> = 10 &#8658; <I>D</I><SUB><I><SMALL>A</SMALL></I></SUB> = 3</P>
<P ALIGN="CENTER"><I>S</I><SUB><I><SMALL>B</SMALL></I></SUB> = 0.2, <I>V</I><SUB><I><SMALL>B</SMALL></I></SUB> = 5 &#8658; <I>D</I><SUB><I><SMALL>B</SMALL></I></SUB> = 1</P>
<P ALIGN="CENTER"><I>D</I><SUB><SMALL>CPU</SMALL></SUB> = 2, <I>V</I><SUB><SMALL>CPU</SMALL></SUB> = <I>V</I><SUB><I><SMALL>A</SMALL></I></SUB> &#43; <I>V</I><SUB><I><SMALL>B</SMALL></I></SUB> &#43; 1 = 16 &#8658;. <I>S</I><SUB><SMALL>CPU</SMALL></SUB> = 0. 125</P>
<P ALIGN="CENTER"><I>Z</I> = 4, <I>N</I> = 20</P>
<P>To initialize the queue lengths, we assume that the 20 jobs are equally distributed among the three queues of CPU, disk A, and disk B:</P>
<P ALIGN="CENTER"><I>Q</I><SUB><SMALL>CPU</SMALL></SUB> = <I>Q</I><SUB><I><SMALL>A</SMALL></I></SUB> = <I>Q</I><SUB><I><SMALL>B</SMALL></I></SUB> = <IMG SRC="images/34-08i.jpg"></IMGI> = 6.67</P>
<P><I>Iteration 1</I></P>
<P>Device response times:</P>
<P ALIGN="CENTER"><I>R</I><SUB><SMALL>CPU</SMALL></SUB> = <I>S</I><SUB><SMALL>CPU</SMALL></SUB>(1 &#43; <I>Q</I><SUB><SMALL>CPU</SMALL></SUB>) = 0.125(1 &#43; 6.77) = 0.92</P>
<P ALIGN="CENTER"><I>R</I><SUB><I><SMALL>A</SMALL></I></SUB> = <I>S</I><SUB><I><SMALL>A</SMALL></I></SUB>(1 &#43; <I>Q</I><SUB><I><SMALL>A</SMALL></I></SUB>) = 0.3(1 &#43; 6.77) = 2.20</P>
<P ALIGN="CENTER"><I>R</I><SUB><I><SMALL>B</SMALL></I></SUB> = <I>S</I><SUB><I><SMALL>B</SMALL></I></SUB>(1 &#43; <I>Q</I><SUB><I><SMALL>B</SMALL></I></SUB>) = 0.2(1 &#43; 6.77) = 1.47</P>
<P>System response time:</P>
<P ALIGN="CENTER"><I>R</I> = <I>R</I><SUB><SMALL>CPU</SMALL></SUB><I>V</I><SUB><SMALL>CPU</SMALL></SUB> &#43; <I>R</I><SUB><I><SMALL>A</SMALL></I></SUB><I>V</I><SUB><I><SMALL>A</SMALL></I></SUB> &#43; <I>R</I><SUB><I><SMALL>B</SMALL></I></SUB><I>V</I><SUB><I><SMALL>B</SMALL></I></SUB> = 0.92 &#215; 16 &#43; 2.20 &#215; 10 &#43; 1.47 &#215; 5 = 44</P>
<P>System throughput:</P>
<P ALIGN="CENTER"><I>X</I> = <I>N</I>/(<I>R</I> &#43; <I>Z</I>) = 20/(44 &#43; 4) = 0.42</P>
<P>Device queue lengths:</P>
<P ALIGN="CENTER"><I>Q</I><SUB><SMALL>CPU</SMALL></SUB> = <I>XR</I><SUB><SMALL>CPU</SMALL></SUB><I>V</I><SUB><SMALL>CPU</SMALL></SUB> = 0.42 &#215; 0.92 &#215; 16 = 6.11</P>
<P ALIGN="CENTER"><I>Q</I><SUB><I><SMALL>A</SMALL></I></SUB> = <I>XR</I><SUB><I><SMALL>A</SMALL></I></SUB><I>V</I><SUB><I><SMALL>A</SMALL></I></SUB> = 0.42 &#215; 2.20 &#215; 10 = 9.17</P>
<P ALIGN="CENTER"><I>Q</I><SUB><I><SMALL>B</SMALL></I></SUB> = <I>XR</I><SUB><I><SMALL>B</SMALL></I></SUB><I>V</I><SUB><I><SMALL>B</SMALL></I></SUB> = 0.42 &#215; 1.47 &#215; 5 = 3.06</P>
<P>Maximum absolute change in device queue lengths:</P>
<P ALIGN="CENTER">&#916;<I>Q</I> = max{|6.67 &#150; 6.11|,|6.67 &#150; 9.17|,|6.67 &#150; 3.06|}</P>
<P ALIGN="CENTER">= max{0.56, 2.5, 3.61} = 3.61</P>
</LIST2><P>Since the maximum absolute change in queue lengths is more than our stopping criterion of 0.01, we continue with the second iteration. In fact, it requires 16 iterations before satisfying the stopping criterion. The response times, throughputs, and queue lengths at the end of these iterations are listed in Table 34.2.
</P>
<P>In this example, we used a stopping criterion of &#916;<I>Q</I> &#8804; 0.01. Other alternatives, although not as good, are to stop when the relative change in response time or throughput is below a certain threshold.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="34-04.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="34-06.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Copyright &copy; <a href="/reference/wiley00001.html">John Wiley &amp; Sons, Inc.</a></font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

</BODY>
</HTML>

<!-- END FOOTER -->

