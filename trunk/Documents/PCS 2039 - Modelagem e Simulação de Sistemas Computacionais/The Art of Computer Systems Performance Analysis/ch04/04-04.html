<HTML>
<HEAD>
<META name=vsisbn content="0471503363">
<META name=vstitle content="Art of Computer Systems Performance Analysis Techniques For Experimental Design Measurements Simulation And Modeling">
<META name=vsauthor content="Raj Jain">
<META name=vsimprint content="Wiley Computer Publishing">
<META name=vspublisher content="John Wiley & Sons, Inc.">
<META name=vspubdate content="05/01/91">
<META name=vscategory content="Web and Software Development: Software Engineering: Simulation and Modeling">







<TITLE>The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling:Types of Workloads</TITLE>

<!-- HEADER -->

<STYLE type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
</STYLE>

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<!--ISBN=0471503363//-->
<!--TITLE=The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling//-->
<!--AUTHOR=Raj Jain//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=04//-->
<!--PAGES=053-055//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="04-03.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="04-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H4 ALIGN="LEFT"><A NAME="Heading9"></A><FONT COLOR="#000077">4.6.2 Ackermann&#146;s Function</FONT></H4>
<P>This kernel has been used to assess the efficiency of the procedure-calling mechanism in ALGOL-like languages. The function has two parameters and is defined recursively. The function Ackermann (3,<I>n</I>) is evaluated for values of <I>n</I> from 1 to 6. The average execution time per call, the number of instructions executed per call, and the amount of stack space required for each call are used to compare various systems.</P>
<P>A listing of the benchmark program in SIMULA is shown in Figure 4.3. The value of the function Ackermann (3,<I>n</I>) is 2<SUP><I>n</I>&#43;3</SUP> &#150; 3. This knowledge is used in the code to verify the implementation of the benchmark. The number of recursive calls in evaluating Ackermann (3,<I>n</I>) has been shown by Wichmann (1976) to be</P>

<TABLE BORDER="2" BORDERCOLOR="#0000" ALIGN="CENTER">
<TR><TD>
<!-- CODE //-->
<PRE>
BEGIN
  INTEGER n;                !Loop index;
  INTEGER j;                !Function value;
  INTEGER num_calls;        !Number of recursive calls;
  INTEGER k;                !Contains 2**(n&#43;3);
  INTEGER k1;               !Contains 4**(n-1);
  REAL t1,t2;               !CPU time values;

  INTEGER PROCEDURE Ackermann(m,n); VALUE m,n; INTEGER m,n;
    Ackermann := IF m=0 THEN n&#43;1
                 ELSE IF n=0 THEN Ackermann(m-1,1)
                      ELSE Ackermann(m-1,Ackermann(m,n-1));

!Main Program;
  k := 16; K1 := 1;          !Initialize k and k1 for n=1;
  FOR n := 1 STEP 1 UNTIL 6 DO
    BEGIN
      t1 := CPUTIME;               !Beginning CPU time;
      j := Ackermann (3,n);        !Compute the function;
      t2 := CPUTIME;               !Ending CPU time;
      IF j &lt&gt k-3 THEN OUTTEXT(&#147;Wrong Value&#148;);
      OUTTEXT(&#147;Net CPU Time for Ackermann (3,&#148;);
      OUTINT(n,1); OUTTEXT(&#147;) is&#148;);
      OUTREAL(t2-t1,7,15); OUTIMAGE;
      Num_calls := (512*k1-15*k&#43;9*n&#43;37)/3;
      OUTTEXT(&#147;CPU Time per call:&#148;);
      OUTREAL((t2-t1)/num_calls.7,15);
      OUTIMAGE;
      ki := 4*k1;           !Update k1 for the next n;
      k := 2*k;             !Update k for the next n;
    END
END
</PRE>
<!-- END CODE //-->
</TABLE>

<P ALIGN="CENTER"><B>FIGURE 4.3</B> SIMULA program to implement Ackermann&#146;s function.</P>
<P ALIGN="CENTER">(512 &#215; 4<SUP><I>n</I>&#150;1</SUP> &#150; 15 &#215; 2<SUP><I>n</I>&#43;3</SUP> &#43; 9<I>n</I> &#43; 37)/3</P>
<P>This expression is used to compute the execution time per call. For Ackermann (3,<I>n</I>), the maximum depth of the procedure calls is 2<SUP><I>n</I>&#43;3</SUP> &#150; 4. Hence, the amount of stack space required doubles when <I>n</I> is increased by 1.</P>
<H4 ALIGN="LEFT"><A NAME="Heading10"></A><FONT COLOR="#000077">4.6.3 Whetstone</FONT></H4>
<P>Used at the British Central Computer Agency, the Whetstone kernel consists of a set of 11 modules designed to match observed dynamic frequency of operations used in 949 ALGOL programs. The kernel exercises such processor features as array addressing, fixed- and floating-point arithmetic, subroutine calls, and parameter passing. It has been translated from ALGOL to FORTRAN, PL/I, and other languages. A listing of the workload in ALGOL can be found in Curnow and Wichmann (1975).
</P>
<P>The results of the Whetstone benchmarks are measured in KWIPS (Kilo Whetstone Instructions Per Second). There are many permutations of the Whetstone benchmark, so it is important to ensure that comparisons across various systems utilize the same source code and that the internal loop counter is defined large enough to reduce timing variability.</P>
<P>Despite its synthetic mix of operations, Whetstone is generally considered a floating-point benchmark and is mostly representative of small engineering/scientific applications that fit into cache memory.</P>
<P>The modules were designed to minimize the impact of known compiler optimizations. Newer compiler optimization techniques can significantly affect the execution time of this workload on a processor. It suffers from other problems of kernels in that there is no I/O and values of input parameters significantly affect the measured performance.</P>
<H4 ALIGN="LEFT"><A NAME="Heading11"></A><FONT COLOR="#000077">4.6.4 LINPACK</FONT></H4>
<P>Developed by Jack Dongarra (1983) of Argonne National Laboratory, this benchmark consists of a number of programs that solve dense systems of linear equations using the UNPACK subroutine package. UNPACK programs can be characterized as having a high percentage of floating-point additions and multiplications. Most of the time is consumed in a set of subroutines called the Basic Linear Algebra Subprograms (BLAS), which are called repeatedly throughout the benchmark.
</P>
<P>The LINPACK benchmarks are compared based upon the execution rate as measured in MFLOPS. The most popular variants solve a 100 &#215; 100 system of equations, either in single or double precision, and have become one of the most widely used benchmarks to gauge engineering/scientific applications performance. For example, many finite element, finite difference, simulation, and regression analysis applications exploit LINPACK-like equation solvers.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="04-03.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="04-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Copyright &copy; <a href="/reference/wiley00001.html">John Wiley &amp; Sons, Inc.</a></font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

</BODY>
</HTML>

<!-- END FOOTER -->

