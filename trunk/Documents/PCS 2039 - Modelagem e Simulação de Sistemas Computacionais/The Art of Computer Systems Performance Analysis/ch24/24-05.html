<HTML>
<HEAD>
<META name=vsisbn content="0471503363">
<META name=vstitle content="Art of Computer Systems Performance Analysis Techniques For Experimental Design Measurements Simulation And Modeling">
<META name=vsauthor content="Raj Jain">
<META name=vsimprint content="Wiley Computer Publishing">
<META name=vspublisher content="John Wiley & Sons, Inc.">
<META name=vspubdate content="05/01/91">
<META name=vscategory content="Web and Software Development: Software Engineering: Simulation and Modeling">







<TITLE>The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling:Introduction to Simulation</TITLE>

<!-- HEADER -->

<STYLE type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
</STYLE>

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<!--ISBN=0471503363//-->
<!--TITLE=The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling//-->
<!--AUTHOR=Raj Jain//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=24//-->
<!--PAGES=403-406//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="24-04.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="24-06.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H4 ALIGN="LEFT"><A NAME="Heading7"></A><FONT COLOR="#000077">24.5.1 Monte Carlo Simulation</FONT></H4>
<P>A static simulation or one without a time axis is called a Monte Carlo simulation. Such simulations are used to model probabilistic phenomenon that do not change characteristics with time. Like a dynamic simulation they require the generation of pseudo-random numbers. Monte Carlo simulations are also used for evaluating nonprobabilistic expressions using probabilistic methods. The following example illustrates one such application.
</P>
<P><B>Example 24.1</B> The following integral is to be evaluated:</P>
<P ALIGN="CENTER"><P ALIGN="CENTER"><IMG SRC="images/24-01d.jpg"></P>
</IMGD></P>
<P>One way to evaluate this integral is to generate uniformly distributed random numbers <I>x</I> and for each number compute a function <I>y</I> as follows:</P>
<P ALIGN="CENTER"><P ALIGN="CENTER"><IMG SRC="images/24-02d.jpg"></P>
</IMGD></P>
<P>The expected value of <I>y</I> is</P>
<P ALIGN="CENTER"><P ALIGN="CENTER"><IMG SRC="images/24-03d.jpg"></P>
</IMGD></P>
<P>Thus, the integral can be evaluated by generating uniformly distributed random numbers <I>x<SUB>i</SUB></I>, computing <I>y<SUB>i</SUB></I>, and then averaging as follows:</P>
<P ALIGN="CENTER"><P ALIGN="CENTER"><IMG SRC="images/24-04d.jpg"></P>
</IMGD></P>
<H4 ALIGN="LEFT"><A NAME="Heading8"></A><FONT COLOR="#000077">24.5.2 Trace-Driven Simulation</FONT></H4>
<P>A simulation using a trace as its input is a <B>trace-driven simulation</B>. A trace is a time-ordered record of events on a real system. Trace-driven simulations are quite common in computer system analyses. They are generally used in analyzing or tuning resource management algorithms. Paging algorithms, cache analysis, CPU scheduling algorithms, deadlock prevention algorithms, and algorithms for dynamic allocation of storage are examples of cases where trace-driven simulation has been successfully used and documented in the literature. In these studies, a trace of the resource demand is used as input to the simulation, which models different algorithms. For example, in order to compare different memory management schemes, a trace of page reference patterns of key programs can be obtained on a system. This trace can then be used to find the optimal set of parameters for a given memory management algorithm or to compare different algorithms.</P>
<P>It should be noted that the traces should be independent of the system under study. For example, a trace of pages fetched from a disk depends upon the working set size and page replacement policy used. This trace could not be used to study other page replacement policies. For that, one would need a trace of pages referenced. Similarly, an instruction trace obtained on one operating system should not be used to analyze another operating system.</P>
<P>Sherman and Brown (1973) point out the following advantages of trace-driven simulations:</P>
<DL>
<DD><B>1.</B>&nbsp;&nbsp;<I>Credibility</I>: The results of a trace-driven simulation are easy to sell to other members of the design team. A trace of page references, for example, has more credibility than references generated randomly using an assumed distribution.
<DD><B>2.</B>&nbsp;&nbsp;<I>Easy Validation</I>: The first step in a trace-driven simulation is to monitor a real system to get the trace. During this monitoring, one can also measure performance characteristics of the system. By comparing the measured performance with that obtained by simulation, one can easily validate a trace-driven model.
<DD><B>3.</B>&nbsp;&nbsp;<I>Accurate Workload</I>: A trace preserves the correlation and interference effects in the workload. No simplification, such as those needed in getting an analytical model of the workload, is required.
<DD><B>4.</B>&nbsp;&nbsp;<I>Detailed Trade-offs</I>: Due to the high level of detail in the workload, it is possible to study the effect of small changes in the model or algorithms.
<DD><B>5.</B>&nbsp;&nbsp;<I>Less Randomness</I>: A trace is a deterministic input. If the simulation is repeated again, the input trace is still the same but the output may be different due to randomness in other parts of the model. Overall, output of a trace-driven model has less variance, which means that a fewer number of repetitions are required to get a desired statistical confidence in the result. Also, if other parts of the system are not random, it is possible to get absolute results in one execution of the model.
<DD><B>6.</B>&nbsp;&nbsp;<I>Fair Comparison</I>: A trace allows different alternatives to be compared under the same input stream. This is a fairer comparison than other simulation models in which input is generated from a random stream and is different for the various alternatives being simulated.
<DD><B>7.</B>&nbsp;&nbsp;<I>Similarity to the Actual Implementation</I>: A trace-driven model is generally very similar to the system being modeled. Thus, when implementing it, one can get a very good feeling for the complexity of implementing a proposed algorithm.
</DL>
<P>The disadvantages of trace-driven simulations are as follows:
</P>
<DL>
<DD><B>1.</B>&nbsp;&nbsp;<I>Complexity</I>: A trace-driven model requires a more detailed simulation of the system. Sometimes, the complexity of the model overshadows the algorithm being modeled.
<DD><B>2.</B>&nbsp;&nbsp;<I>Representativeness</I>: Traces taken on one system may not be representative of the workload on another system. Even on a single system workload may change with time, and thus traces become obsolete faster than other forms of workload models that can be adjusted with time.
<DD><B>3.</B>&nbsp;&nbsp;<I>Finiteness</I>: A trace is a long sequence. A detailed trace of a few minutes of activity on a system may be enough to fill a disk pack. A result based on those few minutes may not be applicable to the activities during the rest of the day.
<DD><B>4.</B>&nbsp;&nbsp;<I>Single Point of Validation</I>: While using traces for validation, one should be careful since the traces give only one point of validation each. An algorithm that is the best for one trace may not be the best for another. One should use a few different traces to validate the results.
<DD><B>5.</B>&nbsp;&nbsp;<I>Detail</I>: The main problem with trace-driven simulation is the high level of detail. Traces are generally very long sequences that have to be read in from a disk and then computation has to be done for each element of the trace.
<DD><B>6.</B>&nbsp;&nbsp;<I>Trade-off</I>: With traces, it is difficult to change workload characteristics. It is not possible to change a trace itself. In order to make conclusions about the impact of changes in workload, a trace for the changed workload is required. Similarly, if a trace contains resource demand characteristics of several jobs, it is difficult to study the effects on individual jobs.
</DL>
<H4 ALIGN="LEFT"><A NAME="Heading9"></A><FONT COLOR="#000077">24.5.3 Discrete-Event Simulations</FONT></H4>
<P>A simulation using a discrete-state model of the system is called a discrete event simulation. This is opposite of continuous-event simulations in which the state of the system takes continuous values. The continuous-state models are used in chemical simulations where the state of the system is described by the concentration of a chemical substance. In computer systems, discrete-event models are used since the state of the system is described by the number of jobs at various devices. Notice that the term &#147;discrete&#148; does not apply to the time values used in the simulation. A discrete-event simulation may use discrete- or continuous-time values.
</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="24-04.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="24-06.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Copyright &copy; <a href="/reference/wiley00001.html">John Wiley &amp; Sons, Inc.</a></font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

</BODY>
</HTML>

<!-- END FOOTER -->

