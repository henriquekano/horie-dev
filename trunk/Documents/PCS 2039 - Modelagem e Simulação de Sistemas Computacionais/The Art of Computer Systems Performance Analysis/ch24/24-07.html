<HTML>
<HEAD>
<META name=vsisbn content="0471503363">
<META name=vstitle content="Art of Computer Systems Performance Analysis Techniques For Experimental Design Measurements Simulation And Modeling">
<META name=vsauthor content="Raj Jain">
<META name=vsimprint content="Wiley Computer Publishing">
<META name=vspublisher content="John Wiley & Sons, Inc.">
<META name=vspubdate content="05/01/91">
<META name=vscategory content="Web and Software Development: Software Engineering: Simulation and Modeling">







<TITLE>The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling:Introduction to Simulation</TITLE>

<!-- HEADER -->

<STYLE type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
</STYLE>

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<!--ISBN=0471503363//-->
<!--TITLE=The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling//-->
<!--AUTHOR=Raj Jain//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=24//-->
<!--PAGES=409-412//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="24-06.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch25/25-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
</P>
<DL>
<DD><B>1.</B>&nbsp;&nbsp;<I>Ordered Linked List</I>: The approach most commonly used in simulation languages such as SIMULA, GPSS, and GASP IV is that of keeping an ordered doubly linked list, as shown in Figure 24.7. The first entry in the list is the next earliest event. Thus, removal is straightforward. To insert a new event, the list is searched to find the right place for the new entry. A number of alternatives for search direction have been proposed. The most common method is to search backward from the highest time value. Alternately, the list could be searched forward from the first entry. Some have even tried keeping a pointer on the middle entry, first determining the half that would contain the right place and then searching forward or backward to determine the place.
<DD><B>2.</B>&nbsp;&nbsp;<I>Indexed Linear List</I>: In this approach, the set of future events is divided into several subsets. Each subset spans a fixed interval &#916;<I>t</I> of the time interval and is maintained as a sublist, as shown in Figure 24.8. An array of indexes is kept such that the <I>i</I>th entry of the index points to the <I>i</I>th sublist that contains events scheduled for the interval [(<I>i</I> - 1)&#916;<I>t</I>, <I>i</I>&#916;<I>t</I>), that is, at or after time (<I>i</I> - 1)&#916;<I>t</I> but before time <I>i</I>&#916;<I>t</I>. Here, &#916;<I>t</I> is an interval specified by the user. Thus, given a new event to be inserted, the required sublist can be determined without any search. The proper sublist is then searched backward to find the position of the new entry.
<P><A NAME="Fig8"></A><A HREF="javascript:displayWindow('images/24-08.jpg',500,315 )"><IMG SRC="images/24-08t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/24-08.jpg',500,315)"><FONT COLOR="#000077"><B>FIGURE 24.8</B></FONT></A>&nbsp;&nbsp;Indexed list.</P>
<BR>A number of variations to this approach have also been proposed based on the argument that the event-hold times (the time between scheduling an event and its occurrence) are not uniformly distributed. In one variation, an attempt is made to keep all lists of the same length, the interval covered by each index entry; that is, &#916;<I>t</I> is variable. Binary search is used to find the proper index entry. In another variation, only the first list is kept sorted; other lists are kept unsorted. A sublist is sorted only when it becomes the first sublist, thereby reducing the sorting overhead.
<BR>An interesting variation of this approach is called <B>calendar queues</B>. It is based on the desk calendars used by human beings to schedule events. A typical desk calendar has 365 pages&#151;one page for each day of the year. All events for a single day are written down on the page corresponding to that day. The events for the same day of the next year can also be written on that page. This will not cause any confusion if the year of occurrence is also written down with the event and the events are deleted after they have taken place. This idea can be easily implemented using an indexed linear list. The interval &#916;<I>t</I> corresponds to a human day, and size of the index corresponds to the number of days in a year. Both these parameters should be carefully chosen so that the number of events per page is small (close to 0 or 1). A procedure to dynmically adjust these two parameters is described by Brown (1988) who also showed that the algorithm takes a fixed amount of time per event regardless of the number of events.
<DD><B>3.</B>&nbsp;&nbsp;<I>Tree Structures</I>: Tree data structures have also been used for simulation event sets. Usually a binary tree is used. The time to search through <I>n</I> events is then log<SUB>2</SUB><I>n</I>.
<BR>A special case of the binary tree is the <B>heap,</B> where each event is stored as a node in the binary tree. Each node can have up to two children, and the event time for each node is smaller than that of its children, if any. This implies that the root always has the earliest event time. The advantage of heaps is that the tree can be stored in an array (as opposed to a linked list) by putting the root at position 1 of the array and its children at positions 2 and 3. The nodes at the next level are kept in array positions 4, 5, 6, 7, and so on, as shown in Figure 24.9. The traversal of a heap is simple because it is easy to find the parents and children of any particular node. The two children of the node in position <I>i</I> are in positions 2<I>i</I> and 2<I>i</I> &#43; 1. The parent of a node in position <I>i</I> is at the position [<I>i</I>/2]. Here, [&#183;] represents the truncation to the next lower integer. The array has to be rearranged partially after each insertion or removal.
<P><A NAME="Fig9"></A><A HREF="javascript:displayWindow('images/24-09.jpg',500,429 )"><IMG SRC="images/24-09t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/24-09.jpg',500,429)"><FONT COLOR="#000077"><B>FIGURE 24.9</B></FONT></A>&nbsp;&nbsp;A heap.</P>
<BR>The heaps can be further extended to <I>k</I>-ary heaps that make use of <I>k</I>-ary trees in which each node has up to <I>k</I> children.
</DL>
<P>The choice of the proper data structure depends upon the distribution of event hold times and the number of events in the future event set. It also depends upon the ease with which various data structures can be implemented in the given programming language. In a study by Reeves (1984), the simple linked list was found to be the most efficient alternative if the number of events was small (less than 20 events). For event sets of sizes 20 to 120, index linear lists were the best, while for larger sets, heaps were found to be the most efficient. Similar conclusions were also drawn in an earlier study by McCormack and Sargent (1979).
</P>
<H3><A NAME="Heading11"></A><FONT COLOR="#000077">EXERCISES</FONT></H3>
<DL>
<DD><B>24.1</B>&nbsp;&nbsp;For each of the following models, identify all classifications that apply to it:
<DL>
<DD><B>a.</B>&nbsp;&nbsp;<I>y</I>(<I>t</I>) = <I>t</I> &#43; 0.2
<DD><B>b.</B>&nbsp;&nbsp;<I>y</I>(<I>t</I>) = <I>t<SUP>2</SUP></I>
<DD><B>c.</B>&nbsp;&nbsp;<I>y</I>(<I>t</I> &#43; 1) = <I>y</I>(<I>t</I>) &#43; &#916, &#916; is not an integer.
<DD><B>d.</B>&nbsp;&nbsp;<I>n</I>(<I>t</I> &#43; 1) = 2<I>n</I>(<I>t</I>) &#43; 3
<DD><B>e.</B>&nbsp;&nbsp;<I>y</I>(<I>t</I>) = sin(<I>wt</I>)
<DD><B>f.</B>&nbsp;&nbsp;<IMG SRC="images/24-01i.jpg"></IMGI>
</DL>
<DD><B>24.2</B>&nbsp;&nbsp;Which type of simulation would you use for the following problems:
<DL>
<DD><B>a.</B>&nbsp;&nbsp;To model destination address reference patterns in a network traffic given that the pattern depends upon a large number of factors.
<DD><B>b.</B>&nbsp;&nbsp;To model scheduling in a multiprocessor system given that the request arrivals have a known distribution.
<DD><B>c.</B>&nbsp;&nbsp;To determine the value of &#960;.
</DL>
<DD><B>24.3</B>&nbsp;&nbsp;What is the unit time approach and why is it not generally used?
</DL>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="24-06.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch25/25-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Copyright &copy; <a href="/reference/wiley00001.html">John Wiley &amp; Sons, Inc.</a></font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

</BODY>
</HTML>

<!-- END FOOTER -->

