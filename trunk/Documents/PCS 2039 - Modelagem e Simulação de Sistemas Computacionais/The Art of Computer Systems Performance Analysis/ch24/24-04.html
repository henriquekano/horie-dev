<HTML>
<HEAD>
<META name=vsisbn content="0471503363">
<META name=vstitle content="Art of Computer Systems Performance Analysis Techniques For Experimental Design Measurements Simulation And Modeling">
<META name=vsauthor content="Raj Jain">
<META name=vsimprint content="Wiley Computer Publishing">
<META name=vspublisher content="John Wiley & Sons, Inc.">
<META name=vspubdate content="05/01/91">
<META name=vscategory content="Web and Software Development: Software Engineering: Simulation and Modeling">







<TITLE>The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling:Introduction to Simulation</TITLE>

<!-- HEADER -->

<STYLE type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
</STYLE>

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<!--ISBN=0471503363//-->
<!--TITLE=The Art of Computer Systems Performance Analysis: Techniques for Experimental Design, Measurement, Simulation, and Modeling//-->
<!--AUTHOR=Raj Jain//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=24//-->
<!--PAGES=401-403//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="24-03.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="24-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H3><A NAME="Heading5"></A><FONT COLOR="#000077">24.4 SELECTING A LANGUAGE FOR SIMULATION</FONT></H3>
<P>Selecting a proper language is probably the most important step in the process of developing a simulation model. An incorrect decision during this step may lead to long development times, incomplete studies, and failures.
</P>
<P>There are four choices: a simulation language, a general-purpose language, extension of a general-purpose language, and a simulation package (such as a network solver). Each choice has its own advantages and disadvantages.</P>
<P>Simulation languages such as SIMULA and SIMSCRIPT save the analyst considerable time when developing a simulation. These languages have builtin facilities for time advancing, event scheduling, entity manipulation, random-variate generation, statistical data collection, and report generation. They allow analysts to spend more time on issues specific to the system being modeled and not worry about issues that are general to all simulations. Also, these languages allow a very readable modular code with good error detection.</P>
<P>A general-purpose language such as Pascal or FORTRAN is chosen for simulation primarily because of an analyst&#146;s familiarity with the language. Most computer system designers and new analysts are not familiar with simulation languages. Also, deadline requirements do not allow time for them to learn a simulation language. Further, simulation languages are often not available on their computer systems. This is why most people write their first simulation in a general-purpose language.</P>
<P>Even for beginners, the time trade-off between a simulation language and a general-purpose language is really not what it appears. If they choose a simulation language, they have to spend time learning the language. In some cases, they may even have to install it on their computer system and see that no pieces are missing. If they choose a general-purpose language, they can get started right away. But they spend time developing routines for event handling, random-number generation, and so forth. Considerable time may be spent in learning about these issues and rediscovering known problems.</P>
<P>This is not to say that analysts should always use simulation languages. There are other considerations, such as efficiency, flexibility, and portability, which may make a general-purpose language the only choice. A model developed in a general-purpose language is more efficient and takes less CPU time. A general-purpose language gives analysts more flexibility by allowing them to take short cuts prohibited in a simulation language. Furthermore, a model developed in a general-purpose language can be easily converted for execution on different computer systems.</P>
<P>To make an objective choice between a simulation language and a general-purpose language, it is suggested that the analyst learn at least one simulation language so that other factors in addition to familiarity will help in the selection of the language.</P>
<P>An extension of a general-purpose language such as GASP (for FORTRAN) is another alternative. These extensions consist of a collection of routines to handle tasks that are commonly required in simulations. Their aim is to provide a compromise in terms of efficiency, flexibility, and portability.</P>
<P>Simulation packages such as QNET4 and RESQ allow the user to define a model using a dialog. The packages have a library of data structures, routines, and algorithms. Their biggest advantage is the time savings that they provide. Using a simulation package, for example, one could develop a model, solve it, and get results in one day. Developing a simulation using a language, on the other hand, may take several days (if not months) depending upon the complexity of the system.</P>
<P>The main problem with the simulation packages is their inflexibility. They provide only those flexibilities that were foreseen by their developers. In most practical situations, analysts run into one or another problem that cannot be modeled by the package. This may force an analyst to make simplifications. Nonetheless, it saves so much time that if a system cannot be modeled analytically, one should look at the possibility of using a simulation package before starting to develop a new simulation model.</P>
<P>Simulation languages can be classified into two categories, continuous simulation languages and discrete-event simulation languages, based on the types of events they simulate. Continuous simulation languages are designed to handle continuous-event models that are generally described by differential equations. Examples of such languages are CSMP and DYNAMO. These languages are popular in chemical system modeling. On the other hand, discrete-event simulation languages are designed to handle discrete-state changes. Two examples of these languages are SIMULA and GPSS. Some languages, such as SIMSCRIPT and GASP, allow discrete, continuous, as well as combined simulations. The latter four are the major languages used by computer systems performance analysts.</P>
<H3><A NAME="Heading6"></A><FONT COLOR="#000077">24.5 TYPES OF SIMULATIONS</FONT></H3>
<BLOCKQUOTE>
<P><B>Monte Carlo method</B> [Origin: after Count Montgomery de Carlo, Italian gambler and random-number generator (1792-1838).] A method of jazzing up the action in certain statistical and number-analytic environments by setting up a book and inviting bets on the outcome of a computation.</P>
<P ALIGN="RIGHT">&#151;S. Kelly-Bootle<BR><I>The Devil&#146;s DP Dictionary</I></P>
</BLOCKQUOTE><P>Among the variety of simulations that are described in the literature, those that would be of interest to computer scientists are Emulation, Monte Carlo Simulation, Trace-Driven Simulation, and Discrete-Event Simulation.
</P>
<P>A simulation using hardware or firmware is called <B>emulation</B>. A terminal emulator, for example, simulates one kind of terminal on another. A processor emulator emulates an instruction set of one processor on another. Even though emulation is a type of simulation, the design issues for emulation are mostly hardware design issues. Hence, emulation is not discussed any further.</P>
<P>The other three types of simulations are described next.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="24-03.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="24-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Copyright &copy; <a href="/reference/wiley00001.html">John Wiley &amp; Sons, Inc.</a></font>
</div>
<!-- all of the reference materials (books) have the footer and subfoot reveresed -->
<!-- reference_subfoot = footer -->
<!-- reference_footer = subfoot -->

</BODY>
</HTML>

<!-- END FOOTER -->

